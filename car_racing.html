<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rally Racer - Stylized 4-Car Challenge</title>
    <!-- Load Three.js (r128) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load Tone.js for audio generation -->
    <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
    <!-- Load Tailwind CSS for UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* Dark Moss Green background to match atmosphere */
            background-color: #26352c; 
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
        }
        #countdown-display {
            font-size: 8rem;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.8); /* Cyan/Teal Glow */
            line-height: 1;
        }
        .position-text {
            font-size: 1.5rem;
            font-weight: 800;
            color: #4cffc8; /* Bright Teal */
            text-shadow: 0 0 5px rgba(76, 255, 200, 0.7);
        }
        .speedometer {
            font-size: 1.2rem;
            font-weight: 700;
            color: #38bdf8; /* Sky Blue */
        }
        /* Style for the Modal to make it centered and smooth */
        #briefing-modal .transform {
            transform: scale(1);
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>

    <!-- UI Overlay for Game Status and Controls (Kept dark and calm) -->
    <div id="ui-overlay" class="absolute top-0 left-0 w-full h-full flex flex-col items-center justify-start pointer-events-none">
        
        <!-- TOP STATUS BAR -->
        <div class="w-full p-4 flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4 items-center justify-center">
            
            <div id="position-display" class="bg-slate-800/80 p-3 rounded-xl shadow-lg text-center w-full sm:w-auto border border-slate-700">
                <span class="text-sm font-semibold text-slate-400">Position:</span> 
                <span id="current-position" class="position-text">N/A</span>
            </div>

            <div class="bg-slate-800/80 text-white p-3 rounded-xl shadow-lg text-center w-full sm:w-auto border border-slate-700">
                <p class="text-xs font-semibold text-slate-400">SPEED</p>
                <p id="speedometer" class="speedometer">0 MPH</p>
            </div>

            <div id="status-message-container" class="bg-slate-800/80 text-white p-3 rounded-xl shadow-lg transition duration-500 text-center w-full sm:w-auto border border-slate-700">
                <h1 id="status-title" class="text-xl font-bold text-sky-400">4-Car Rally Challenge</h1>
                <p id="status-subtitle" class="text-sm text-slate-300">Press **W** or **Start Race** to begin.</p>
            </div>
            
            <div class="bg-slate-800/80 text-white p-3 rounded-xl shadow-lg text-center w-full sm:w-auto border border-slate-700">
                <p class="text-sm font-semibold text-slate-400">Lap: <span id="lap-count" class="text-teal-400 font-extrabold">0/3</span></p>
                <p class="text-sm font-semibold text-slate-400">Time: <span id="time-display" class="text-green-400 font-extrabold">00:00.000</span></p>
                <p class="text-xs font-semibold mt-1 text-slate-400">Best Time: <span id="best-time-display" class="text-sky-400">--</span></p>
            </div>
        </div>

        <!-- Mini-Map -->
        <div class="absolute top-4 left-4 bg-slate-800/80 rounded-xl shadow-2xl p-2 pointer-events-none border border-slate-700">
            <h3 class="text-xs font-bold text-slate-300 mb-1 text-center">MINI-MAP (4 Cars)</h3>
            <canvas id="mini-map-canvas" width="150" height="150" class="rounded-lg border border-slate-600"></canvas>
        </div>

        <!-- Center Countdown -->
        <div id="countdown-container" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-white pointer-events-none hidden">
            <span id="countdown-display">3</span>
        </div>
        
        <!-- Action Buttons -->
        <div class="absolute bottom-10 flex space-x-4 pointer-events-auto">
            <button id="briefing-button" class="px-6 py-2 bg-teal-600 text-white font-bold rounded-lg shadow-xl hover:bg-teal-500 transition duration-300 transform active:scale-95">
                Race Briefing âœ¨
            </button>
            <button id="reset-button" class="px-6 py-2 bg-sky-600 text-white font-bold rounded-lg shadow-xl hover:bg-sky-500 transition duration-300 transform active:scale-95">
                Start Race
            </button>
        </div>
    </div>

    <!-- Custom Modal for Briefing/Messages -->
    <div id="briefing-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden pointer-events-auto">
        <div class="bg-slate-800 text-white p-6 rounded-xl shadow-2xl max-w-lg w-full transform transition-all duration-300" style="opacity: 0;">
            <h2 id="modal-title" class="text-2xl font-bold mb-4 text-sky-400">Race Briefing</h2>
            <div id="modal-content" class="text-slate-300 space-y-3 text-sm">
                <!-- Content will be injected here -->
                <p class="text-center text-lg py-4">Generating strategy...</p>
                <div class="w-full bg-slate-700 rounded-full h-2.5 dark:bg-slate-700">
                    <div class="bg-sky-400 h-2.5 rounded-full animate-pulse" style="width: 100%"></div>
                </div>
            </div>
            <button id="close-modal" class="mt-6 w-full py-2 bg-emerald-600 rounded-lg font-semibold hover:bg-emerald-500 transition">
                Got it, Let's Race!
            </button>
        </div>
    </div>

    <script>
        // --- Gemini API Configuration ---
        const apiKey = ""; 
        const TEXT_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        const TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
        
        // --- Game Setup Variables ---
        let scene, camera, renderer;
        let carGroup; // Only player car group is separate
        let opponentCars = []; // Array of opponent objects
        let keys = { w: false, a: false, s: false, d: false };
        
        // Car Physics Variables
        const maxSpeed = 0.2;
        const accelerationRate = 0.005;
        const brakingRate = 0.01;
        const roadFriction = 0.98; 
        const offRoadFriction = 0.85; // Lower friction for off-road areas
        const wallHitDamping = 0.05; // Used only for car-to-car collision now
        const turningSpeed = 0.03; 
        let speed = 0; 
        const carCollisionRadius = 1.0; // Scaled down to match new car size
        
        // Audio Variables
        let engineSynth, crashNoise;
        const MIN_ENGINE_FREQ = 80; 
        const MAX_ENGINE_FREQ = 350; 
        const MAX_SPEED_MPH = 120; 
        let audioContextStarted = false; 
        let commentatorSpoken = { crash: false, lap: false, lead: false, start: false };
        let lastPosition = '4TH'; // Default to last place in a 4-car race
        
        // AI Variables
        let trackCurve; 
        let playerProgress = 0; 
        
        // Game State Variables
        const maxLaps = 3;
        let lapCount = 0;
        let lapTimer = 0;
        let startTime = 0;
        let isRaceStarted = false;
        let isGameOver = false;
        let isCountingDown = false; 
        let canCrossFinishLine = false; 
        let bestTime = localStorage.getItem('bestRaceTime') || null;

        // Track boundary points 
        const trackCenterPoints = [];
        const trackWidth = 10;
        
        const TRACK_SEGMENT_COUNT = 80; 

        // Scenery/People variables
        const SCENERY_DENSITY = 0.5; // Increased density
        let movingPeople = []; // Array for people to be animated

        // Mini-Map Variables
        let mapCanvas, mapCtx;
        const MAP_CENTER_X = 75; 
        const MAP_CENTER_Y = 75; 
        const WORLD_MAX_COORD = 50; 


        // UI Elements
        const statusTitle = document.getElementById('status-title');
        const statusSubtitle = document.getElementById('status-subtitle');
        const resetButton = document.getElementById('reset-button');
        const briefingButton = document.getElementById('briefing-button');
        const lapCountDisplay = document.getElementById('lap-count');
        const timeDisplay = document.getElementById('time-display');
        const bestTimeDisplay = document.getElementById('best-time-display');
        const countdownContainer = document.getElementById('countdown-container');
        const countdownDisplay = document.getElementById('countdown-display');
        const currentPositionDisplay = document.getElementById('current-position');
        const speedometerDisplay = document.getElementById('speedometer');
        const briefingModal = document.getElementById('briefing-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const closeModalButton = document.getElementById('close-modal');

        // --- LLM API Helper Functions (TTS and Text) ---

        /**
         * Converts base64 string to ArrayBuffer.
         */
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /**
         * Converts PCM 16-bit audio data (from API) to a WAV Blob.
         */
        function pcmToWav(pcm16, sampleRate = 24000) {
            const buffer = new ArrayBuffer(44 + pcm16.length * 2);
            const view = new DataView(buffer);

            // RIFF identifier 'RIFF'
            writeString(view, 0, 'RIFF');
            // file length (excluding RIFF identifier and length field)
            view.setUint32(4, 36 + pcm16.length * 2, true);
            // RIFF format 'WAVE'
            writeString(view, 8, 'WAVE');
            // format chunk identifier 'fmt '
            writeString(view, 12, 'fmt ');
            // format chunk length
            view.setUint32(16, 16, true);
            // sample format (raw PCM)
            view.setUint16(20, 1, true);
            // channel count
            view.setUint16(22, 1, true);
            // sample rate
            view.setUint32(24, sampleRate, true);
            // byte rate (sample rate * block align)
            view.setUint32(28, sampleRate * 2, true);
            // block align (bytes per sample * channels)
            view.setUint16(32, 2, true);
            // bits per sample
            view.setUint16(34, 16, true);
            // data chunk identifier 'data'
            writeString(view, 36, 'data');
            // data chunk length
            view.setUint32(40, pcm16.length * 2, true);

            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(44 + i * 2, pcm16[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        /**
         * Retries a fetch call with exponential backoff.
         */
        async function fetchWithRetry(url, options, maxRetries = 5, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) return response;
                    if (response.status === 429 || response.status >= 500) {
                         // Throttle or Server Error - retry
                    } else {
                        // Non-retryable error
                        console.error('Non-retryable API error:', response.status);
                        return response;
                    }
                } catch (error) {
                    // Network or other generic error
                }
                await new Promise(resolve => setTimeout(resolve, delay * (2 ** i)));
            }
            throw new Error('API request failed after multiple retries.');
        }


        // --- Gemini API Integrations ---
        
        /**
         * Generates text commentary using the LLM and plays it using TTS.
         * @param {string} prompt The context for the commentary.
         */
        async function generateAndPlayCommentary(prompt) {
            try {
                // Step 1: LLM call to get the commentary text
                const textPayload = {
                    contents: [{ parts: [{ text: `Act as a high-energy, excitable sports commentator. Generate a single, short, and dramatic phrase based on this event: "${prompt}"` }] }],
                };

                const textResponse = await fetchWithRetry(TEXT_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(textPayload)
                });
                
                const textResult = await textResponse.json();
                const text = textResult.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) throw new Error('Failed to generate commentary text.');

                // Step 2: TTS call to convert text to audio
                const audioPayload = {
                    contents: [{ parts: [{ text: text }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Fenrir" } // Excitable voice
                            }
                        }
                    },
                    model: "gemini-2.5-flash-preview-tts"
                };

                const audioResponse = await fetchWithRetry(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(audioPayload)
                });

                const audioResult = await audioResponse.json();
                const part = audioResult?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;
                    
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    const audio = new Audio(audioUrl);
                    audio.play();
                } else {
                    console.warn("TTS Audio data missing or invalid format (expected L16).");
                }

            } catch (error) {
                console.error("Gemini TTS Error:", error);
            }
        }

        /**
         * Generates a pre-race strategy briefing using the LLM.
         */
        async function getRaceBriefing() {
            modalTitle.textContent = 'Race Briefing';
            modalContent.innerHTML = `
                <p class="text-center text-lg py-4">Generating strategy...</p>
                <div class="w-full bg-slate-700 rounded-full h-2.5 dark:bg-slate-700">
                    <div class="bg-sky-400 h-2.5 rounded-full animate-pulse" style="width: 100%"></div>
                </div>
            `;
            briefingModal.classList.remove('hidden');
            briefingModal.querySelector('.transform').style.opacity = 1;

            const trackDescription = "This is a 4-car Off-Road Challenge. There are NO barriers, so going off the wide asphalt track is permitted but will severely reduce your speed due to the deep forest green terrain. The track is a square loop with four large, wide, 90-degree corners. It rewards drivers who brake early and accelerate smoothly out of the apex. There is one long main straight, which is the finish straight (North side).";
            
            const userQuery = `Given the track described as: "${trackDescription}", provide a race strategy focusing on: 1. Braking/Apex strategy, 2. Acceleration zones, and 3. Overall racing mentality to beat three AI opponents, emphasizing the risk of off-roading. Format the response as a single JSON object.`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "brakingStrategy": { "type": "STRING", "description": "Advice on when and how to brake for the corners." },
                            "accelerationStrategy": { "type": "STRING", "description": "Advice on when to apply throttle for maximum speed, especially avoiding the off-road." },
                            "raceMentality": { "type": "STRING", "description": "Mental approach to maintaining position, timing overtakes, and managing the soft track boundaries." }
                        }
                    }
                }
            };
            
            try {
                const response = await fetchWithRetry(TEXT_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (jsonText) {
                    const parsedJson = JSON.parse(jsonText);
                    modalContent.innerHTML = `
                        <h3 class="text-xl font-semibold text-teal-400">1. Braking & Apex Strategy</h3>
                        <p>${parsedJson.brakingStrategy}</p>
                        <h3 class="text-xl font-semibold text-teal-400 mt-4">2. Acceleration Zones (Stay on Asphalt!)</h3>
                        <p>${parsedJson.accelerationStrategy}</p>
                        <h3 class="text-xl font-semibold text-teal-400 mt-4">3. Race Mentality</h3>
                        <p>${parsedJson.raceMentality}</p>
                    `;
                } else {
                    modalContent.innerHTML = `<p class="text-red-400">Error: Could not retrieve briefing. Try again!</p>`;
                }
            } catch (error) {
                console.error("Gemini Text API Error:", error);
                modalContent.innerHTML = `<p class="text-red-400">Error: Network failure or invalid response. Check console for details.</p>`;
            }
        }


        // --- Tone.js (Non-LLM Audio) ---
        
        /**
         * Initializes Tone.js for sound effects, safely ensuring the AudioContext starts.
         */
        function setupAudio() {
            if (audioContextStarted) return true;
            try {
                // Ensure audio context is started on user interaction (critical fix)
                Tone.start(); 
                
                // 1. Engine Sound (Sawtooth Oscillator for a mechanical drone)
                engineSynth = new Tone.Oscillator(MIN_ENGINE_FREQ, "sawtooth").toDestination();
                engineSynth.volume.value = -18; 
                engineSynth.start();

                // 2. Crash Sound (Quick filtered noise burst)
                crashNoise = new Tone.NoiseSynth({
                    "noise": { "type": "pink" },
                    "envelope": {
                        "attack": 0.001, "decay": 0.1, "sustain": 0, "release": 0.01
                    },
                    "filterEnvelope": {
                        "baseFrequency": 200, "octaves": 3, "attack": 0.001, "decay": 0.1, "sustain": 0
                    }
                }).toDestination();
                crashNoise.volume.value = -5;
                audioContextStarted = true;
                return true;
            } catch (e) {
                console.error("Audio setup failed:", e);
                return false;
            }
        }
        
        /**
         * Updates the engine sound based on the car's current speed.
         */
        function updateEngineSound() {
            if (!audioContextStarted) return;
            const freqRatio = Math.abs(speed) / maxSpeed;
            const targetFreq = MIN_ENGINE_FREQ + freqRatio * (MAX_ENGINE_FREQ - MIN_ENGINE_FREQ);
            const targetVolume = -18 + freqRatio * 10; 

            engineSynth.frequency.linearRampToValueAtTime(targetFreq, Tone.now() + 0.1);
            engineSynth.volume.linearRampToValueAtTime(targetVolume, Tone.now() + 0.1);
        }

        /**
         * Triggers the crash sound.
         */
        function playCrashSound() {
            if (audioContextStarted && crashNoise) {
                crashNoise.triggerAttackRelease(0.1);
                commentatorSpoken.crash = true; // Set flag to allow commentator to speak only once per crash event
            }
        }


        // --- Scenery Functions ---

        /**
         * Creates a simple, stylized tree.
         */
        function createTree() {
            const treeGroup = new THREE.Group();
            treeGroup.name = 'scenery';
            
            // Trunk (Brown)
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b4513, // Saddle Brown 
                roughness: 0.8 
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Foliage (Dark Green)
            const foliageGeometry = new THREE.ConeGeometry(3, 8, 12);
            const foliageMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x006400, // Dark Green
                roughness: 0.5,
                metalness: 0.1
            });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 8;
            foliage.castShadow = true;
            treeGroup.add(foliage);
            
            return treeGroup;
        }

        /**
         * Creates a simple, stylized house.
         */
        function createHouse() {
            const houseGroup = new THREE.Group();
            houseGroup.name = 'scenery';

            // Body (Light Blue/Gray Siding)
            const bodyGeometry = new THREE.BoxGeometry(7, 5, 7);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xa9b0b4, // Light Slate Gray 
                roughness: 0.5 
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 2.5;
            body.castShadow = true;
            houseGroup.add(body);

            // Roof (Red/Brown)
            const roofGeometry = new THREE.CylinderGeometry(0.1, 5, 7, 4, 1);
            const roofMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x800000, // Maroon Red
                roughness: 0.5 
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.rotation.y = Math.PI / 4; // Align square roof with square body
            roof.position.y = 5.5;
            roof.castShadow = true;
            houseGroup.add(roof);

            return houseGroup;
        }
        
        /**
         * Creates a simple, low-poly person character.
         */
        function createPerson() {
            const personGroup = new THREE.Group();
            personGroup.name = 'person';
            
            // Head (Orange/Skin tone)
            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffa07a, roughness: 0.8 }); // Light Salmon
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 3.5;
            personGroup.add(head);

            // Body (Blue Shirt)
            const bodyGeometry = new THREE.BoxGeometry(1.0, 2.0, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x1e90ff, roughness: 0.5 }); // Dodger Blue
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 2.0;
            personGroup.add(body);

            personGroup.scale.set(0.8, 0.8, 0.8); // Slightly smaller scale
            personGroup.position.y = 0; // Ensures base is on the ground
            personGroup.castShadow = true;

            return personGroup;
        }


        /**
         * Randomly places trees, houses, and people along the track boundary.
         */
        function addScenery() {
            const MIN_DISTANCE_FROM_ROAD = trackWidth / 2 + 5; 
            const MAX_DISTANCE_FROM_ROAD = 50; 
            
            // Clear previous scenery AND people
            scene.children.filter(child => child.name === 'scenery' || child.name === 'person').forEach(scenery => scene.remove(scenery));
            movingPeople.length = 0; // Clear people array

            const NUM_SEGMENTS = trackCurve.points.length * 10; 

            for (let i = 0; i < NUM_SEGMENTS; i++) {
                if (Math.random() > SCENERY_DENSITY) continue;

                const t = i / NUM_SEGMENTS;
                const point = trackCurve.getPointAt(t);
                const tangent = trackCurve.getTangentAt(t).normalize();
                const binormal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();

                // 60% chance for tree/house, 40% chance for person
                let object;
                const roll = Math.random();
                
                if (roll < 0.2) { // 20% House
                    object = createHouse();
                } else if (roll < 0.6) { // 40% Tree (Total 60% for static scenery)
                    object = createTree();
                } else { // 40% Person
                    object = createPerson();
                    movingPeople.push(object); // Add to the array for animation
                }
                
                // Randomly choose left or right side
                const side = Math.random() < 0.5 ? 1 : -1;
                
                // Random distance from the road edge
                const offsetDistance = MIN_DISTANCE_FROM_ROAD + Math.random() * (MAX_DISTANCE_FROM_ROAD - MIN_DISTANCE_FROM_ROAD);
                
                // Calculate position: center point + offset in the binormal direction
                const position = point.clone().add(binormal.clone().multiplyScalar(offsetDistance * side));

                object.position.copy(position);
                object.rotation.y = Math.random() * Math.PI * 2; // Random rotation
                
                // Ensure object is on the ground plane (y=0)
                object.position.y = 0; 
                scene.add(object);
            }
        }


        // --- Game Initialization ---

        function init() {
            scene = new THREE.Scene();
            
            // --- PBR Lighting Setup ---
            const hemisphereLight = new THREE.HemisphereLight(0x8a9e91, 0x000000, 3); 
            scene.add(hemisphereLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 4); 
            directionalLight.position.set(50, 50, 50); 
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -60;
            directionalLight.shadow.camera.right = 60;
            directionalLight.shadow.camera.top = 60;
            directionalLight.shadow.camera.bottom = -60;
            scene.add(directionalLight);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Initialize Mini-Map Context
            mapCanvas = document.getElementById('mini-map-canvas');
            mapCtx = mapCanvas.getContext('2d');

            createSkybox();
            
            // Create the player car once
            carGroup = createCar(0x1d4ed8); // Player Car: Deep Blue
            scene.add(carGroup);

            updateBestTimeUI();
            
            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            resetButton.addEventListener('click', () => { 
                if (!audioContextStarted) setupAudio();
                if (!isCountingDown) startCountdown(); 
            });
            briefingButton.addEventListener('click', getRaceBriefing);
            closeModalButton.addEventListener('click', () => briefingModal.classList.add('hidden'));
        }

        function createSkybox() { 
            const size = 1000;
            const skyGeo = new THREE.BoxGeometry(size, size, size);
            // Skybox Dark Slate Green
            const skyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x4f6457, // Dark Slate Green
                side: THREE.BackSide 
            });
            const sky = new THREE.Mesh(skyGeo, skyMaterial);
            scene.add(sky);
        }

        /**
         * Creates a smaller, more stylized car with a cabin and chassis.
         * @param {number} color Hex color for the car body.
         * @returns {THREE.Group} Group containing the car parts.
         */
        function createCar(color) { 
            const group = new THREE.Group();
            
            // --- Dimensions (Scaled Down & Stylized) ---
            const chassisW = 1.3;
            const chassisH = 0.3;
            const chassisL = 2.8;
            const cabinW = 1.0;
            const cabinH = 0.7;
            const cabinL = 1.5;
            const wheelR = 0.3;
            const wheelT = 0.2; // Thickness

            // --- Materials ---
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: color, 
                metalness: 0.8,    // Metallic paint look
                roughness: 0.1,    // Glossy finish
            }); 
            
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                metalness: 0.1,
                roughness: 0.3,
            });

            const wheelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222, // Darker gray for rubber
                metalness: 0.1, 
                roughness: 0.9 
            });

            // 1. Chassis (Bottom Base)
            const chassisGeometry = new THREE.BoxGeometry(chassisW, chassisH, chassisL);
            const chassis = new THREE.Mesh(chassisGeometry, bodyMaterial);
            chassis.position.set(0, wheelR + chassisH / 2, 0); 
            chassis.castShadow = true;
            group.add(chassis);
            
            // 2. Cabin (Top Section)
            const cabinGeometry = new THREE.BoxGeometry(cabinW, cabinH, cabinL);
            const cabin = new THREE.Mesh(cabinGeometry, bodyMaterial);
            // Position above the chassis
            cabin.position.set(0, wheelR + chassisH + cabinH / 2, -0.3); 
            cabin.castShadow = true;
            group.add(cabin);

            // 3. Windshield/Window (Black/Glass look)
            const windshieldGeometry = new THREE.BoxGeometry(cabinW * 0.9, cabinH * 0.5, 0.05);
            const windshield = new THREE.Mesh(windshieldGeometry, windowMaterial);
            windshield.position.set(0, wheelR + chassisH + cabinH * 0.8, -cabinL/2);
            group.add(windshield);


            // 4. Wheels
            const wheelGeometry = new THREE.CylinderGeometry(wheelR, wheelR, wheelT, 12);

            const createWheel = (x, z) => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2; 
                wheel.position.set(x, wheelR, z);
                wheel.castShadow = true;
                return wheel;
            };
            
            const wheelOffsetW = chassisW / 2 + wheelT / 2;
            const wheelOffsetL = chassisL / 2 - 0.5;

            group.add(createWheel(wheelOffsetW, wheelOffsetL));
            group.add(createWheel(-wheelOffsetW, wheelOffsetL));
            group.add(createWheel(wheelOffsetW, -wheelOffsetL));
            group.add(createWheel(-wheelOffsetW, -wheelOffsetL));
            
            group.position.y = 1; // Initial lift off ground
            
            return group;
        }

        function createTrack() { 
            // --- UPDATED PBR Ground Material (Deep Forest Green) ---
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x296e2b, // Deep Forest Green (Highly saturated to avoid looking gray)
                roughness: 0.9, 
                metalness: 0.0 
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            const points = [
                new THREE.Vector3( 0, 0, 50 ),
                new THREE.Vector3( 40, 0, 50 ),
                new THREE.Vector3( 50, 0, 40 ),
                new THREE.Vector3( 50, 0, -40 ),
                new THREE.Vector3( 40, 0, -50 ),
                new THREE.Vector3( -40, 0, -50 ),
                new THREE.Vector3( -50, 0, -40 ),
                new THREE.Vector3( -50, 0, 40 ),
                new THREE.Vector3( -40, 0, 50 ),
                new THREE.Vector3( 0, 0, 50 ),
            ];

            trackCurve = new THREE.CatmullRomCurve3(points, true, 'centripetal'); 
            trackCenterPoints.length = 0; 

            const TRACK_SEGMENT_COUNT = 80; 
            // Road Material (Dark Asphalt Gray) - Increased contrast with new green floor
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333, // Dark Asphalt Gray
                metalness: 0.1, 
                roughness: 0.8  
            }); 
            
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xf1f5f9 }); // White center line
            
            const curveLength = trackCurve.getLength();
            const segmentCount = TRACK_SEGMENT_COUNT;
            const segmentLength = curveLength / segmentCount;

            for (let i = 0; i < segmentCount; i++) {
                const t = i / segmentCount;
                const tNext = (i + 1) / segmentCount;
                const point = trackCurve.getPointAt(t);
                
                trackCenterPoints.push(point);

                // Road Segment
                const roadSegment = new THREE.Mesh(new THREE.BoxGeometry(trackWidth, 0.1, segmentLength * 1.05), roadMaterial);
                roadSegment.position.copy(point).add(new THREE.Vector3(0, 0.05, 0));
                roadSegment.lookAt(trackCurve.getPointAt(tNext));
                roadSegment.receiveShadow = true;
                scene.add(roadSegment);
                
                // Center Line
                if (i % 8 === 0) { 
                    const lineSegment = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.11, segmentLength * 0.5), lineMaterial);
                    lineSegment.position.copy(point).add(new THREE.Vector3(0, 0.06, 0));
                    lineSegment.lookAt(trackCurve.getPointAt(tNext));
                    scene.add(lineSegment);
                }
            }

            // Finish Line 
            // Dimmed Finish Line Color (Teal)
            const finishLineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x06b6d4, 
                emissive: 0x06b6d4, 
                emissiveIntensity: 0.5 
            });
            const startPoint = trackCurve.getPointAt(0);
            const startTangent = trackCurve.getTangentAt(0).normalize();
            
            const line = new THREE.Mesh(new THREE.BoxGeometry(trackWidth - 1, 0.12, 0.2), finishLineMaterial);
            line.position.copy(startPoint).add(new THREE.Vector3(0, 0.07, 0));
            line.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), startTangent);
            line.rotation.y += Math.PI / 2; 
            line.name = 'finishLine';
            scene.add(line);
            
            // Add scenery after track is defined
            addScenery();
        }
        
        // Simplified checkCollision for soft boundaries (no more hard barriers)
        function checkCollision(position) { 
            let minDistanceSq = Infinity;
            let closestPoint = new THREE.Vector3();
            
            for (let i = 0; i < trackCenterPoints.length; i += 2) { 
                const distSq = position.distanceToSquared(trackCenterPoints[i]);
                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestPoint = trackCenterPoints[i];
                }
            }

            const distance = Math.sqrt(minDistanceSq);
            
            // If within road width (trackWidth / 2) return 1 (road friction)
            if (distance < trackWidth / 2) { 
                return 1; // On road
            } else {
                return 0; // Off road (use offRoadFriction)
            }
        }

        function startCountdown() {
            if (isRaceStarted || isGameOver || isCountingDown) return;
            isCountingDown = true;
            
            resetButton.classList.add('hidden');
            briefingButton.classList.add('hidden'); 
            countdownContainer.classList.remove('hidden');
            statusTitle.textContent = 'Get Ready!';
            statusSubtitle.textContent = 'Hold W to accelerate after GO!';
            commentatorSpoken.start = false;

            let count = 3;
            countdownDisplay.textContent = count;

            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownDisplay.textContent = count;
                } else if (count === 0) {
                    countdownDisplay.textContent = 'GO!';
                    if (!commentatorSpoken.start) {
                        generateAndPlayCommentary(`The countdown has reached GO! The race is on!`);
                        commentatorSpoken.start = true;
                    }
                } else {
                    clearInterval(interval);
                    countdownContainer.classList.add('hidden');
                    isCountingDown = false;
                    startGame();
                }
            }, 1000);
        }

        function startGame() {
            isRaceStarted = true;
            startTime = Date.now();
            canCrossFinishLine = false; 
            statusTitle.textContent = 'RACE ON!';
            statusSubtitle.textContent = '4-Car Rally Challenge!';
            commentatorSpoken.crash = false;
            commentatorSpoken.lap = false;
            commentatorSpoken.lead = false;
        }

        function onKeyDown(event) { 
            if (isGameOver || isCountingDown) return;
            
            switch (event.key.toLowerCase()) {
                case 'w': case 'arrowup': keys.w = true; 
                    if (!audioContextStarted) setupAudio(); 
                    if (!isRaceStarted && !isCountingDown) startCountdown();
                    break;
                case 's': case 'arrowdown': keys.s = true; break;
                case 'a': case 'arrowleft': keys.a = true; break;
                case 'd': case 'arrowright': keys.d = true; break; 
            }
        }

        function onKeyUp(event) { 
            switch (event.key.toLowerCase()) {
                case 'w': case 'arrowup': keys.w = false; break;
                case 's': case 'arrowdown': keys.s = false; break;
                case 'a': case 'arrowleft': keys.a = false; break;
                case 'd': case 'arrowright': keys.d = false; break;
            }
        }

        function calculatePlayerProgress() { 
            let minDistanceSq = Infinity;
            let closestT = 0;
            
            for (let i = 0; i <= 100; i++) {
                const t = i / 100;
                const point = trackCurve.getPointAt(t);
                const distSq = carGroup.position.distanceToSquared(point);
                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestT = t;
                }
            }
            playerProgress = closestT;
        }

        function updateRacePosition() {
            const playerTotalProgress = lapCount + playerProgress;

            // Compile all total progress values (Player + 3 Opponents)
            let totalProgresses = [playerTotalProgress];
            opponentCars.forEach(op => totalProgresses.push(op.lapCount + op.progress));
            
            // Sort in descending order to determine rank
            totalProgresses.sort((a, b) => b - a);

            // Find the player's rank (1-indexed)
            const playerRank = totalProgresses.indexOf(playerTotalProgress) + 1;
            
            const rankSuffix = playerRank === 1 ? 'ST' : playerRank === 2 ? 'ND' : playerRank === 3 ? 'RD' : 'TH';
            const currentPosition = `${playerRank}${rankSuffix}`;
            currentPositionDisplay.textContent = currentPosition;
            
            // Commentary logic for position change
            if (isRaceStarted && playerRank === 1 && lastPosition !== '1ST') {
                if (!commentatorSpoken.lead) {
                    generateAndPlayCommentary(`The driver takes the lead! What a move!`);
                    commentatorSpoken.lead = true;
                }
            }
            // If the player falls behind, reset the lead flag
            if (playerRank > 1) {
                commentatorSpoken.lead = false;
            }
            lastPosition = currentPosition;
        }

        function updateSpeedometer() { 
            const speedRatio = Math.abs(speed) / maxSpeed;
            const mph = Math.round(speedRatio * MAX_SPEED_MPH);
            speedometerDisplay.textContent = `${mph} MPH`;
        }
        
        /**
         * Animates the low-poly people, making them subtly move and look at the player car if nearby.
         */
        function animatePeople(time) {
            if (!carGroup) return;
            const playerCarPosition = carGroup.position;
            const animationSpeed = 0.0005;
            const rotationSpeed = 0.005;
            const maxShift = 0.1;

            movingPeople.forEach(person => {
                // Subtle positional shift (walking in place)
                // Use a unique offset (like a hash from the UUID) for varied animation
                const uniqueOffset = parseInt(person.uuid.slice(-3), 16) / 4095; 
                person.position.x += Math.sin(time * animationSpeed + uniqueOffset * Math.PI * 2) * maxShift * 0.01;
                person.position.z += Math.cos(time * animationSpeed + uniqueOffset * Math.PI * 2) * maxShift * 0.01;
                
                // Slow ambient rotation (looking around)
                person.rotation.y += rotationSpeed * 0.05;

                // If player is close, turn to face the player car (more engaging)
                const distanceToPlayer = person.position.distanceTo(playerCarPosition);
                if (distanceToPlayer < 30) { 
                    person.lookAt(playerCarPosition.x, person.position.y, playerCarPosition.z);
                    // Lock rotation to Y-axis only
                    person.rotation.x = 0; 
                    person.rotation.z = 0;
                }
            });
        }

        function updatePhysics() {
            if (isGameOver || !carGroup || !isRaceStarted) return;

            if (keys.a) {
                carGroup.rotation.y += turningSpeed * speed;
            }
            if (keys.d) {
                carGroup.rotation.y -= turningSpeed * speed;
            }

            if (keys.w) {
                speed = Math.min(speed + accelerationRate, maxSpeed);
            } else if (keys.s) {
                speed = Math.max(speed - brakingRate, -maxSpeed / 2);
            } else {
                const collisionType = checkCollision(carGroup.position);
                // Apply friction based on whether we are on road (1) or off road (0)
                const friction = (collisionType === 1) ? roadFriction : offRoadFriction;
                speed *= friction;
                if (Math.abs(speed) < 0.001) speed = 0; 
            }

            if (speed !== 0) {
                const forwardVector = new THREE.Vector3(
                    -Math.sin(carGroup.rotation.y) * speed, 
                    0,
                    -Math.cos(carGroup.rotation.y) * speed  
                );
                
                const proposedPosition = carGroup.position.clone().add(forwardVector);
                
                // Since barriers are removed, we always allow movement, but friction will slow down off-road.
                carGroup.position.copy(proposedPosition); 

                let hitObstacle = false;
                
                // Collision check against ALL opponents
                opponentCars.forEach(opponent => {
                    const distanceToOpponent = carGroup.position.distanceTo(opponent.group.position);
                    const collisionThreshold = carCollisionRadius * 2;
                    
                    if (distanceToOpponent < collisionThreshold) {
                        speed *= wallHitDamping * 2; // Slow down drastically on collision
                        hitObstacle = true;
                    }
                });
                
                if (hitObstacle && !commentatorSpoken.crash) {
                    playCrashSound();
                    generateAndPlayCommentary(`A huge collision! The cars have tangled!`);
                } else if (!hitObstacle && commentatorSpoken.crash) {
                    commentatorSpoken.crash = false; // Reset crash flag if no longer colliding
                }
            }
        }
        
        function updateOpponent() { 
            if (!trackCurve || !isRaceStarted) return;

            opponentCars.forEach(opponent => {
                opponent.progress += opponent.speed;
                
                if (opponent.progress >= 1.0) {
                    opponent.lapCount++;
                    opponent.progress %= 1;
                    if (opponent.lapCount >= maxLaps) {
                        // If any opponent finishes, it's game over and they win.
                        gameOver(false, opponent.color); 
                    }
                }

                const point = trackCurve.getPointAt(opponent.progress);
                
                // Opponent position needs to be slightly elevated (around Y=0.7) to clear the ground
                opponent.group.position.copy(point).add(new THREE.Vector3(0, 0.7, 0));
                
                const nextPoint = trackCurve.getPointAt((opponent.progress + 0.01) % 1);
                
                // Opponent looks ahead
                opponent.group.lookAt(nextPoint.clone().add(new THREE.Vector3(0, 0.7, 0)));
            });
        }


        function checkLapCrossing() {
            if (!isRaceStarted || isGameOver) return;
            
            const lineZ = 50; 
            const carZ = carGroup.position.z;
            // Check if player is near the start/finish line area
            const inStartArea = carGroup.position.x > -5 && carGroup.position.x < 5;

            if (inStartArea) {
                if (!canCrossFinishLine && carZ < lineZ - 5) {
                    // Passed the line going away (South), now ready to cross
                    canCrossFinishLine = true;
                } 
                else if (canCrossFinishLine && carZ >= lineZ - 5) {
                    // Passed the line going towards (North)
                    lapCount++;
                    canCrossFinishLine = false; 
                    updateUI();
                    
                    if (lapCount >= maxLaps) {
                        gameOver(true); 
                    } else if (lapCount > 0) {
                        // Commentary on completing a lap
                        generateAndPlayCommentary(`Lap ${lapCount} completed! Still pushing hard!`);
                    }
                }
            }
        }
        
        function formatTime(ms) { 
            const date = new Date(ms);
            const minutes = date.getUTCMinutes().toString().padStart(2, '0');
            const seconds = date.getUTCSeconds().toString().padStart(2, '0');
            const milliseconds = date.getUTCMilliseconds().toString().padStart(3, '0');
            return `${minutes}:${seconds}.${milliseconds}`;
        }

        function updateTimer() { 
            if (isRaceStarted && !isGameOver) {
                lapTimer = Date.now() - startTime;
                timeDisplay.textContent = formatTime(lapTimer);
            }
        }

        function updateUI() { 
            lapCountDisplay.textContent = `${lapCount}/${maxLaps}`;
        }

        function updateBestTimeUI() { 
            if (bestTime) {
                bestTimeDisplay.textContent = formatTime(bestTime);
            } else {
                bestTimeDisplay.textContent = '--';
            }
        }

        function gameOver(playerWon, winnerColor = null) {
            isGameOver = true;
            isRaceStarted = false;
            resetButton.classList.remove('hidden');
            briefingButton.classList.remove('hidden'); 
            resetButton.textContent = 'Play Again';
            if (audioContextStarted) updateEngineSound(); 

            if (playerWon) {
                const finalTime = lapTimer;
                let message = `You finished the race in ${formatTime(finalTime)}!`;

                if (!bestTime || finalTime < bestTime) {
                    bestTime = finalTime;
                    localStorage.setItem('bestRaceTime', bestTime);
                    message += " **NEW BEST TIME!**";
                }
                statusTitle.textContent = 'YOU WIN!';
                statusSubtitle.textContent = message;
                generateAndPlayCommentary(`The checkered flag waves! The driver takes the victory!`);

            } else {
                 statusTitle.textContent = 'YOU LOST!';
                 // Find winning opponent's color for the message (simplistic)
                 const colorNames = {
                    0xb91c1c: 'Red',
                    0xfacc15: 'Yellow',
                    0x10b981: 'Green'
                 }
                const colorName = colorNames[winnerColor] || 'An opponent';
                statusSubtitle.textContent = `${colorName} won the race. Try again!`;
                generateAndPlayCommentary(`And that's the end! The opponent crosses the line first!`);
            }
        }

        function resetGame() {
            isGameOver = false;
            isRaceStarted = false;
            isCountingDown = false;
            speed = 0;
            lapCount = 0;
            lapTimer = 0;
            playerProgress = 0;
            canCrossFinishLine = false;
            commentatorSpoken = { crash: false, lap: false, lead: false, start: false };
            lastPosition = '4TH'; // Total 4 cars

            // --- Multi-Opponent Setup ---
            // 1. Clear old opponents from scene and array
            opponentCars.forEach(op => scene.remove(op.group));
            opponentCars = [];

            // 2. Clear and recreate all scenery (including people)
            addScenery();

            // 3. Setup car positions
            const opponentColors = [0xb91c1c, 0xfacc15, 0x10b981]; // Red, Yellow, Green
            const baseOpponentSpeed = 0.0006;

            const startPoint = trackCurve.getPointAt(0);
            const nextPoint = trackCurve.getPointAt(0.001);
            const trackTangent = nextPoint.clone().sub(startPoint).normalize();
            const startBinormal = new THREE.Vector3(0, 1, 0).cross(trackTangent).normalize();
            const initialRotationY = Math.atan2(trackTangent.x, trackTangent.z) + Math.PI; // Face forward

            // Stagger start position for 4 cars
            const startOffsets = [4.5, 1.5, -1.5, -4.5]; // Player at 1.5, opponents at 4.5, -1.5, -4.5
            const carYOffset = 0.7; // Y offset for the new smaller cars

            // Position Player (Blue car)
            carGroup.position.copy(startPoint).add(startBinormal.clone().multiplyScalar(startOffsets[1])).add(new THREE.Vector3(0, carYOffset, 0));
            carGroup.rotation.y = initialRotationY;

            // Position Opponents
            for (let i = 0; i < 3; i++) {
                const carGroup = createCar(opponentColors[i]);
                scene.add(carGroup); 
                carGroup.position.copy(startPoint).add(startBinormal.clone().multiplyScalar(startOffsets[i === 0 ? 0 : i + 1])).add(new THREE.Vector3(0, carYOffset, 0));
                carGroup.rotation.y = initialRotationY;

                opponentCars.push({
                    id: i,
                    group: carGroup,
                    progress: 0, // Start from the line
                    lapCount: 0,
                    // Slightly varied speeds to make the race dynamic
                    speed: baseOpponentSpeed * (1 + (i * 0.05) + Math.random() * 0.01), 
                    color: opponentColors[i]
                });
            }
            // --- End Multi-Opponent Setup ---

            // Set initial camera position: behind the car, aligned with its starting direction
            const offset = new THREE.Vector3(0, 5, 10); 
            offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), initialRotationY);

            camera.position.copy(carGroup.position.clone().add(offset));
            camera.lookAt(carGroup.position);
            // --- End Start Alignment Logic ---


            // Reset UI
            statusTitle.textContent = '4-Car Rally Challenge';
            statusSubtitle.textContent = 'Press **W** or **Start Race** to begin.';
            resetButton.classList.remove('hidden');
            briefingButton.classList.remove('hidden');
            resetButton.textContent = 'Start Race';
            timeDisplay.textContent = '00:00.000';
            currentPositionDisplay.textContent = 'N/A';
            speedometerDisplay.textContent = '0 MPH';
            updateUI();
            if (audioContextStarted) updateEngineSound(); 
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();

            if (!isGameOver) {
                if (isRaceStarted) {
                    calculatePlayerProgress();
                    updatePhysics();
                    updateOpponent(); 
                    checkLapCrossing();
                    updateTimer();
                    updateRacePosition();
                }
                animatePeople(currentTime); // Animate the people regardless of race status
                if (audioContextStarted) updateEngineSound(); 
                updateSpeedometer(); 
                // Only draw map if track is initialized
                if (trackCurve) drawMiniMap(); 
            }

            // Update Camera Position (Chase Cam)
            if (carGroup) {
                // offset (0, 5, 10) means 10 units back (local +Z), 5 units up (local +Y)
                const offset = new THREE.Vector3(0, 5, 10);
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), carGroup.rotation.y);
                
                // Camera lag/smoothing for a better feel
                camera.position.lerp(carGroup.position.clone().add(offset), 0.1); 
                camera.lookAt(carGroup.position);
            }
            
            renderer.render(scene, camera);
        }

        function worldToMap(v) { 
            return {
                x: MAP_CENTER_X + (v.x / WORLD_MAX_COORD) * MAP_CENTER_X * 0.8, 
                y: MAP_CENTER_Y - (v.z / WORLD_MAX_COORD) * MAP_CENTER_Y * 0.8  
            };
        }

        function drawMiniMap() { 
            if (!mapCtx || !trackCurve) return;

            // Mini-Map background matching the dark theme (Semi-transparent off-road)
            mapCtx.fillStyle = 'rgba(41, 110, 43, 0.8)'; 
            mapCtx.fillRect(0, 0, 150, 150);

            // Draw Road
            mapCtx.beginPath();
            mapCtx.strokeStyle = '#333333'; // Dark Asphalt Road
            mapCtx.lineWidth = 10;
            
            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const point3D = trackCurve.getPointAt(t);
                const mapPoint = worldToMap(point3D);

                if (i === 0) {
                    mapCtx.moveTo(mapPoint.x, mapPoint.y);
                } else {
                    mapCtx.lineTo(mapPoint.x, mapPoint.y);
                }
            }
            mapCtx.closePath();
            mapCtx.stroke();

            // Draw start line (Teal)
            const startPoint3D = trackCurve.getPointAt(0);
            const mapStart = worldToMap(startPoint3D);
            mapCtx.beginPath();
            mapCtx.strokeStyle = '#06b6d4'; 
            mapCtx.lineWidth = 3;
            mapCtx.arc(mapStart.x, mapStart.y, 4, 0, 2 * Math.PI); 
            mapCtx.stroke();
            
            // Draw all opponent cars
            opponentCars.forEach(opponent => {
                const opponentMap = worldToMap(opponent.group.position);
                mapCtx.beginPath();
                mapCtx.arc(opponentMap.x, opponentMap.y, 4, 0, 2 * Math.PI);
                mapCtx.fillStyle = `#${opponent.color.toString(16).padStart(6, '0')}`;
                mapCtx.fill();
            });

            // Draw player car (on top)
            const playerMap = worldToMap(carGroup.position);
            mapCtx.beginPath();
            mapCtx.arc(playerMap.x, playerMap.y, 4, 0, 2 * Math.PI);
            mapCtx.fillStyle = '#1d4ed8'; // Blue player car
            mapCtx.fill();
        }


        function onWindowResize() { 
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start the Game on Load ---
        window.onload = function () {
            init();       // Initialize scene and renderer
            createTrack(); // THEN create track elements (Road, Ground, Scenery)
            resetGame();  // THEN setup cars and camera
            animate();
        };

    </script>
</body>
</html>
